# autograder-jeremy_berchtold

## Sketch Installation and Testing
First started with finding and building Sketch. I started with [https://github.com/asolarlez/sketch-frontend/wiki](https://github.com/asolarlez/sketch-frontend/wiki) which contained a .tar.gz pre-compiled setup.
This didn't end up working because I had an "Outdated Java Version". Turns out this was an issue with OpenJDK saying "11.0.11" as the version, whereas Sketch was checking for "1.6". Sketch's Java version checking code was not correct so it falsely wouldn't let me run it. I then compiled from source (turns out the newer source version commented out the Java Version check) and everything worked fine (after waiting 20+ minutes for Maven to access remotes).

Then I started experimenting with Sketch. I found the first parts of the manual [https://people.csail.mit.edu/asolar/manual.pdf](https://people.csail.mit.edu/asolar/manual.pdf) very helpful for a quick introduction. 
I implemented the doubling Sketch example from the manual first, where the hole is the coefficient of x and the target is t = x+x. From there, I implemented the example we covered in class with `7 + 4 + 2 + {0,1}` which was supposed to equal `14`. I added a rule with a branch in the hole (`if (??) return a; ...`) like the main paper for this homework, and it worked! Wohoo! Much easier to use than Z3.

## Racket Implementation
(see `autograder.rkt` for code)

From here, I decided to implement an automated system for applying simple mPy rules, like the 7+4+2... example from class. This did nowhere near as much as the main paper did, but it did have some success. Firstly, I restricted the types to integers. I understood the generic-typing they did in the paper by using essentially a union struct that contains all types as members. However, I decided to focus just on integers since I knew I could get it done within the time frame.

The input to my program is a professor reference program, a student program, and a set of rules. The professor program should produce the correct result (in this case `14`). The student program should not produce the correct result, but should have an `{0}` target for fixing using the ruleset. The input programs are all Sexprs and the ruleset is a list of simple Sexpr rules.

```
Professor Reference:
'(+ 7 (+ 4 (+ 2 1)))

Student Program:
'(+ 7 (+ 4 (+ 2 (target 0))))

Rules:
'(
	(+ n 1)
	(- n 1))
 ```
 
 My program then converts both programs to Sketch programs with a very simple transpiler. My transpiler matches different expr types like `+`, or `target` and converts them to strings of Sketch code.
 Additionally, the ruleset generates a separate Sketch function for each rule and a main rule function called `applyRules(int n)` that applies all the rules to `n`. I don't currently have support for prioritizing minimum changes. Additionally, I don't currently support multiple `(target n)` expressions, because each rule only generates one function. To fix this I could generate multiple functions per rule, or inline the rules so the holes are duplicated.
 
 ```
 // Autogenerated Sketch code from the inputs above
 int applyRule0(int n) {
	if (??) return n;
	return (n) + (1);
}
int applyRule1(int n) {
	if (??) return n;
	return (n) - (1);
}
int applyRules(int n) {
	return applyRule1(applyRule0(n));
}
int professorReferenceImpl() {
	return (7) + ((4) + ((2) + (1)));
}
int studentImpl() {
	return (7) + ((4) + ((2) + (applyRules(0))));
}
harness void main() {
	assert professorReferenceImpl() == studentImpl();
}
```
Sketch then outputs the following, showing the rule `n+1` was used (which is correct in this example as `0+1` is equal to `1` which matches the professor's reference).
(only showing the relevant snippet for brevity, but see `sketchoutput.txt` for more info)
```
void applyRule0 (int n, ref int _out)/*output.sk:1*/
{
  _out = n + 1;
  return;
}
/*output.sk:5*/

void applyRule1 (int n, ref int _out)/*output.sk:5*/
{
  _out = n;
  return;
}
/*output.sk:9*/
```
As you can see, rule 0 (`n+1`) is applied, but rule 1 (`n-1`) is not (simply leaving `n` as a result).

